/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: trf_msg.proto */

#ifndef PROTOBUF_C_trf_5fmsg_2eproto__INCLUDED
#define PROTOBUF_C_trf_5fmsg_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003000 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _TrfMsg__APIVersion TrfMsg__APIVersion;
typedef struct _TrfMsg__LibraryVersion TrfMsg__LibraryVersion;
typedef struct _TrfMsg__AddrCand TrfMsg__AddrCand;
typedef struct _TrfMsg__Transport TrfMsg__Transport;
typedef struct _TrfMsg__Display TrfMsg__Display;
typedef struct _TrfMsg__ClientHello TrfMsg__ClientHello;
typedef struct _TrfMsg__ServerHello TrfMsg__ServerHello;
typedef struct _TrfMsg__ServerReject TrfMsg__ServerReject;
typedef struct _TrfMsg__AddrPF TrfMsg__AddrPF;
typedef struct _TrfMsg__ClientCap TrfMsg__ClientCap;
typedef struct _TrfMsg__ServerCap TrfMsg__ServerCap;
typedef struct _TrfMsg__Endpoint TrfMsg__Endpoint;
typedef struct _TrfMsg__ClientDispReq TrfMsg__ClientDispReq;
typedef struct _TrfMsg__ServerDisp TrfMsg__ServerDisp;
typedef struct _TrfMsg__ClientReq TrfMsg__ClientReq;
typedef struct _TrfMsg__ServerAckReq TrfMsg__ServerAckReq;
typedef struct _TrfMsg__DisplayReq TrfMsg__DisplayReq;
typedef struct _TrfMsg__ClientFReq TrfMsg__ClientFReq;
typedef struct _TrfMsg__ServerNotifyChunk TrfMsg__ServerNotifyChunk;
typedef struct _TrfMsg__ServerAckFReq TrfMsg__ServerAckFReq;
typedef struct _TrfMsg__CursorData TrfMsg__CursorData;
typedef struct _TrfMsg__Disconnect TrfMsg__Disconnect;
typedef struct _TrfMsg__ChannelOpen TrfMsg__ChannelOpen;
typedef struct _TrfMsg__MessageWrapper TrfMsg__MessageWrapper;


/* --- enums --- */


/* --- messages --- */

/**
 *  @brief API version message
 *The initial message exchanged between server and client should be the API
 *versions. In the test versions, the API is not considered stable; any
 *differences in API version from server to client, including patch versions,
 *should be considered unstable.
 */
struct  _TrfMsg__APIVersion
{
  ProtobufCMessage base;
  /**
   * Major release version
   */
  uint32_t api_major;
  /**
   * Minor release version
   */
  uint32_t api_minor;
  /**
   * Patch version
   */
  uint32_t api_patch;
  /**
   *  @brief Versions of installed transport libraries 
   */
  size_t n_lv;
  TrfMsg__LibraryVersion **lv;
};
#define TRF_MSG__APIVERSION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__apiversion__descriptor) \
    , 0, 0, 0, 0,NULL }


/**
 *  @brief Library version message
 *A message containing the library name as well as the version integer and
 *minimum compatible version. A samplle version number is constructed as
 *follows:
 *Major version:      ((uint16_t) MY_LIBRARY_VERSION_MAJOR) << 48
 *Minor version:      ((uint16_t) MY_LIBRARY_VERSION_MINOR) << 32
 *Patch version:      ((uint16_t) MY_LIBRARY_VERSION_PATCH) << 16
 *Library specific:   ((uint16_t) MY_LIBRARY_SPECIFIC_NUM)
 *The only official library supported by LibTRF is Libfabric, with a library
 *ID number of 1. Custom transport libraries should use an ID number between
 *1024-2047.
 */
struct  _TrfMsg__LibraryVersion
{
  ProtobufCMessage base;
  /**
   * Library identifier
   */
  uint32_t lib;
  /**
   * Library version
   */
  uint64_t version;
  /**
   * Minimum compatible version
   */
  uint64_t compat;
};
#define TRF_MSG__LIBRARY_VERSION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__library_version__descriptor) \
    , 0, 0, 0 }


/**
 *  @brief Connection address candidates
 *Clients and servers exchange addressing information in order to determine
 *fabrics which can reach the link. Note that currently there is no support
 *for routing outside of a broadcast domain, although many fabric types such
 *as RoCEv1 do not support this feature as well.
 */
struct  _TrfMsg__AddrCand
{
  ProtobufCMessage base;
  /**
   * Interface address
   */
  char *addr;
  /**
   * Netmask
   */
  int32_t netmask;
  /**
   * Preflight check port
   */
  int32_t port;
  /**
   * Link speed
   */
  int32_t speed;
};
#define TRF_MSG__ADDR_CAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__addr_cand__descriptor) \
    , (char *)protobuf_c_empty_string, 0, 0, 0 }


/**
 *  @brief Transport candidates
 *Transport candidates contain data obtained from the fabric provider,
 *serialized for transmission over the network. Currently, there is only
 *support for Libfabric and some of the transports which it contains, with
 *testing performed on the verbs;ofi_rxm and tcp;ofi_rxm transports only.
 */
struct  _TrfMsg__Transport
{
  ProtobufCMessage base;
  /**
   * Transport provider name e.g. "tcp;ofi_rxm"
   */
  char *name;
  /**
   * Transport wire protocol e.g. "FI_PROTO_RXM"
   */
  char *proto;
  /**
   * Transport provider routing information
   */
  char *route;
};
#define TRF_MSG__TRANSPORT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__transport__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string }


/**
 *  @brief Display/Viewport information
 *A display message is sent by the source in response to a display request,
 *indicating which displays are available to the source, as well as extra
 *metadata such as the texture formats and display group IDs.
 */
struct  _TrfMsg__Display
{
  ProtobufCMessage base;
  /**
   *  @brief Display ID
   *A display identifier uniquely identifies the monitor within a TRF
   *context. It is an opaque value, without any intrinsic meaning and as
   *such may be assigned randomly. 
   *Independent server contexts may reuse the display identifiers.
   */
  uint32_t id;
  /**
   *  @brief Display friendly name
   *This name should be presented to API and end users. It is recommended
   *that functions which set this value be predictable so as to allow for
   *automated setup. For instance, it may be set to the display name.
   */
  char *name;
  /**
   *  @brief Width in pixels 
   */
  uint32_t width;
  /**
   *  @brief Height in pixels 
   */
  uint32_t height;
  /**
   *  @brief Refresh rate 
   *The refresh rate is used to determine frame pacing when clients
   *request frame data updates be sent to them. If this value is not set,
   *frame requests always begin processing immediately without being
   *deferred to the next vblank, which may result in repeated frames and
   *excessive bandwidth utilization.
   */
  int32_t rate;
  /**
   *  @brief Natively supported texture formats
   *The actual definition of texture formats are stored externally.
   *This field may be repeated, in case multiple texture formats are
   *natively supported. Currently, LibTRF supports only one texture format,
   *and the API will select the first item in the list should this field be
   *repeated.
   */
  size_t n_tex_fmt;
  uint32_t *tex_fmt;
  /**
   *  @brief Display Group ID (DGID)
   *Display groups are designed to allow servers to multiplex display
   *sources without the need to run multiple discrete instances of
   *LibTRF. For instance, a single LibTRF server running on a VM host
   *could act as the framebuffer source for multiple virtual machines.
   *Displays within a group can be positioned in a group coordinate space,
   *allowing the client to determine positioning for a multi-monitor
   *setup.
   */
  uint32_t dgid;
  /**
   *  @brief The relative X position of the monitor. 
   */
  int32_t x_offset;
  /**
   *  @brief The relative Y position of the monitor. 
   */
  int32_t y_offset;
};
#define TRF_MSG__DISPLAY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__display__descriptor) \
    , 0, (char *)protobuf_c_empty_string, 0, 0, 0, 0,NULL, 0, 0, 0 }


/**
 *  @brief Client hello
 *This must be the first message sent over the negotiation channel.
 *It should contain the client's LibTRF version.
 */
struct  _TrfMsg__ClientHello
{
  ProtobufCMessage base;
  /**
   * API version
   */
  TrfMsg__APIVersion *version;
};
#define TRF_MSG__CLIENT_HELLO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__client_hello__descriptor) \
    , NULL }


/**
 *  @brief Server hello
 *Should the client hello API version match the version supported by the
 *server, this message should be sent.
 */
struct  _TrfMsg__ServerHello
{
  ProtobufCMessage base;
  /**
   * New session ID
   */
  uint64_t new_session_id;
};
#define TRF_MSG__SERVER_HELLO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__server_hello__descriptor) \
    , 0 }


/**
 *  @brief Server rejection
 *Currently, the only reason for a server rejection is that the API version
 *has mismatched between the client and server. More reasons, such as
 *server overload are planned.
 */
struct  _TrfMsg__ServerReject
{
  ProtobufCMessage base;
  /**
   *  @brief Server API version
   *This should contain the server API version to be sent to the client,
   *in order to inform the user which API version is required to allow for
   *successful communication with the server.
   */
  TrfMsg__APIVersion *version;
};
#define TRF_MSG__SERVER_REJECT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__server_reject__descriptor) \
    , NULL }


/**
 *  @brief Address preflight candidates
 *Currently unused.
 */
struct  _TrfMsg__AddrPF
{
  ProtobufCMessage base;
  /**
   * Address candidates
   */
  size_t n_addrs;
  TrfMsg__AddrCand **addrs;
};
#define TRF_MSG__ADDR_PF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__addr_pf__descriptor) \
    , 0,NULL }


/**
 *  @brief Client capabilities
 *A ClientCap message contains the available fabric transports supported by
 *the client. Currently, this information is sourced entirely from the
 *Libfabric API.
 */
struct  _TrfMsg__ClientCap
{
  ProtobufCMessage base;
  /**
   *  @brief The list of transports supported by the client. 
   */
  size_t n_transports;
  TrfMsg__Transport **transports;
};
#define TRF_MSG__CLIENT_CAP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__client_cap__descriptor) \
    , 0,NULL }


/**
 *  @brief Server capabilities
 *The server should examine a ClientCap message, sending back the
 *best transport common between both the client and server. For instance,
 *Verbs transports should be preferred over non-accelerated TCP transports,
 *determined on the server side.
 */
struct  _TrfMsg__ServerCap
{
  ProtobufCMessage base;
  /**
   *  @brief The recommended client bind address. 
   *This may optionally be used by the client to bind to a specific
   *interface suggested by the server to be the most likely to be
   *functional.
   */
  char *bind_addr;
  /**
   *  @brief Transport to use, selected by the server. 
   */
  TrfMsg__Transport *transport;
};
#define TRF_MSG__SERVER_CAP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__server_cap__descriptor) \
    , (char *)protobuf_c_empty_string, NULL }


/**
 *  @brief Created endpoint name
 *Once a client has created an endpoint, the details should be sent to the 
 *server in order to determine the address the server should listen for.
 */
struct  _TrfMsg__Endpoint
{
  ProtobufCMessage base;
  /**
   *  @brief Transport containing details of the endpoint which was just
   *created by the client.
   */
  TrfMsg__Transport *transport;
};
#define TRF_MSG__ENDPOINT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__endpoint__descriptor) \
    , NULL }


/**
 *  @brief Client display list request
 *The client should send this data to determine the list of displays
 *on the server side.
 */
struct  _TrfMsg__ClientDispReq
{
  ProtobufCMessage base;
  /**
   * Unused
   */
  uint32_t info;
};
#define TRF_MSG__CLIENT_DISP_REQ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__client_disp_req__descriptor) \
    , 0 }


/**
 *  @brief Server display list 
 *This should be sent in response to a ClientDispReq message, containing the
 *displays available for the client to use.
 */
struct  _TrfMsg__ServerDisp
{
  ProtobufCMessage base;
  /**
   * List of displays on server side
   */
  size_t n_displays;
  TrfMsg__Display **displays;
};
#define TRF_MSG__SERVER_DISP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__server_disp__descriptor) \
    , 0,NULL }


/**
 *  @brief Client request
 *A client request contains the list of displays the client wishes the server
 *enable. See the DisplayReq message for more details.
 */
struct  _TrfMsg__ClientReq
{
  ProtobufCMessage base;
  /**
   * Requested displays from server
   */
  size_t n_display;
  TrfMsg__DisplayReq **display;
};
#define TRF_MSG__CLIENT_REQ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__client_req__descriptor) \
    , 0,NULL }


/**
 *  @brief Server request acknowledgement
 *A server request acknowledgement contains a list of displays IDs that were
 *requested by the client as well as the status of the request.
 */
struct  _TrfMsg__ServerAckReq
{
  ProtobufCMessage base;
  /**
   *  @brief Display ID list 
   */
  size_t n_display_ids;
  uint32_t *display_ids;
  /**
   *  @brief Display ID status.
   *For instance, display_ids[0] has a corresponding return code of
   *return_codes[0]. The return codes' meanings must be in line with the
   *POSIX.1-2008 standard. Most of the common POSIX error codes are also
   *available on Windows, inside errno.h.
   */
  size_t n_return_codes;
  uint32_t *return_codes;
};
#define TRF_MSG__SERVER_ACK_REQ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__server_ack_req__descriptor) \
    , 0,NULL, 0,NULL }


/**
 *  @brief Display initialization request
 *This message requests the server initialize the capture source with
 *the specified parameters. This indicates that resources should be set up
 *and memory be allocated in preparation for frame requests.
 */
struct  _TrfMsg__DisplayReq
{
  ProtobufCMessage base;
  /**
   *  @brief Requested display ID 
   */
  uint32_t id;
  /**
   *  @brief Requested display width
   *The width may differ from the display's native width if downscaling is
   *preferred. However, LibTRF does not support downscaling functionality,
   *and as such the implementation is up to the user's application.
   */
  uint32_t width;
  /**
   *  @brief Requested display height
   *The height may differ from the display's native height if downscaling
   *is preferred. However, LibTRF does not support downscaling
   *functionality, and as such the implementation is up to the user's
   *application.
   */
  uint32_t height;
  /**
   *  @brief Requested texture format
   *The texture format must be within the supported texture format list
   *sent in the initial display list message. An API for texture format
   *transcoding support is planned, but currently unsupported.
   */
  uint32_t tex_fmt;
};
#define TRF_MSG__DISPLAY_REQ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__display_req__descriptor) \
    , 0, 0, 0, 0 }


/**
 *  @brief Client frame update request
 *This message should be sent as soon as the client has received a frame,
 *processed it, with the supplied buffer ready to receive new data. Behaviour
 *on the server side may be controlled with the flags argument.
 */
struct  _TrfMsg__ClientFReq
{
  ProtobufCMessage base;
  /**
   *  @brief Display ID to update 
   */
  uint32_t id;
  /**
   *  @brief The current frame number counter. 
   */
  uint32_t frame_cntr;
  /**
   *  @brief Client receive address in virtual memory.
   *This address may not be a memory region offset.
   */
  uint64_t addr;
  /**
   *  @brief Client receive rkey.
   *The remote access key for the client.
   */
  uint64_t rkey;
  /**
   *  @brief Client receive raw key. Currently unsupported.
   *Fabrics with key sizes that exceed 64-bits may use this field. The
   *raw_rkey field takes precedence over the rkey field, so should be
   *set to a NULL value if unused.
   */
  ProtobufCBinaryData raw_key;
  /**
   *  @brief Flags used to control the operation.
   *For instance, a client may request the server return data immediately,
   *ignoring any imposed vertical sync delays, or retransmit the current
   *frame. 
   */
  uint64_t flags;
};
#define TRF_MSG__CLIENT_FREQ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__client_freq__descriptor) \
    , 0, 0, 0, 0, {0,NULL}, 0 }


/**
 *  @brief DMA completion notification for a data chunk  
 *While a ServerAckFReq message should be sent once a frame is ready, this
 *may introduce additional latency on the receiver side due to the fact that
 *the read and write operations occur sequentially. To allow for some degree
 *of parallelization, the server may send notifications when chunks of data
 *have been sent.
 *Note that the processing of such notifications can be rather expensive on
 *both ends, and as such a reasonable chunk size should be selected in
 *accordance with the available network bandwidth as well as the total frame
 *size.
 */
struct  _TrfMsg__ServerNotifyChunk
{
  ProtobufCMessage base;
  /**
   *  @brief The display ID that was updated. 
   */
  uint32_t id;
  /**
   *  @brief The region that was updated. 
   */
  uint32_t frame_cntr;
  /**
   *  @brief Mode indicator. Currently, the following modes are defined:
   *0:  The notification contains a raw offset from the start of the frame
   *buffer in bytes, as well as its length.
   *1:  The notification contains the coordinates and size of a rectangle,
   *describing the region that was updated.
   */
  uint32_t mode;
  /**
   *  @brief Raw update chunk offset 
   */
  uint64_t offset;
  /**
   *  @brief Length of the data past the offset that was updated 
   */
  uint64_t offset_len;
  /**
   *  @brief Rectangle X position 
   */
  uint32_t rect_x;
  /**
   *  @brief Rectangle Y position 
   */
  uint32_t rect_y;
  /**
   *  @brief Rectangle width 
   */
  uint32_t rect_width;
  /**
   *  @brief Rectangle height 
   */
  uint32_t rect_height;
};
#define TRF_MSG__SERVER_NOTIFY_CHUNK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__server_notify_chunk__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0 }


/**
 *  @brief Frame request acknowledgement  
 *The server should send a frame request acknowledgement after the frame has
 *been sent and the buffer is safe to read from. In most fabric providers,
 *such as Verbs, RMA read/write operations do not return a confirmation on
 *the target side, and if these operations do in fact return data, this
 *should not be relied on. Instead, clients should wait for this message as
 *a confirmation that the buffer is ready.
 */
struct  _TrfMsg__ServerAckFReq
{
  ProtobufCMessage base;
  /**
   *  @brief The display ID that was updated. 
   */
  uint32_t id;
  /**
   *  The identifier for the newly updated frame. 
   */
  uint32_t frame_cntr;
};
#define TRF_MSG__SERVER_ACK_FREQ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__server_ack_freq__descriptor) \
    , 0, 0 }


/**
 *  @brief Cursor data update
 *If the display source contains a cursor, the cursor position information
 *should be sent separately. To update the cursor shape, the values 
 *width and height should be set to non-zero values, with tex_fmt and
 *bytes being set to the cursor data type and data respectively.
 */
struct  _TrfMsg__CursorData
{
  ProtobufCMessage base;
  /**
   * Display group ID
   */
  uint32_t dgid;
  /**
   * Cursor X position
   */
  uint32_t x;
  /**
   * Cursor Y position
   */
  uint32_t y;
  /**
   * Cursor X hotspot
   */
  uint32_t hpx;
  /**
   * Cursor Y hotspot
   */
  uint32_t hpy;
  /**
   * Cursor image width
   */
  uint32_t width;
  /**
   * Cursor image height
   */
  uint32_t height;
  /**
   * Cursor image format
   */
  uint32_t tex_fmt;
  /**
   * Raw image data
   */
  ProtobufCBinaryData data;
};
#define TRF_MSG__CURSOR_DATA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__cursor_data__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, {0,NULL} }


/**
 *  @brief Disconnect message
 *The server or client may send a disconnect message. The receiver should
 *then treat the connection as closed and release the resources associated
 *with the sender. Determining the client is done through the use of the 
 *session_id value inside of the parent message wrapper.
 */
struct  _TrfMsg__Disconnect
{
  ProtobufCMessage base;
  /**
   * Extra info e.g. error, unused
   */
  uint32_t info;
};
#define TRF_MSG__DISCONNECT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__disconnect__descriptor) \
    , 0 }


/**
 *  @brief Channel fast open
 *Currently reserved for future use.
 */
struct  _TrfMsg__ChannelOpen
{
  ProtobufCMessage base;
  /**
   * Channel type
   */
  uint32_t type;
};
#define TRF_MSG__CHANNEL_OPEN__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__channel_open__descriptor) \
    , 0 }


typedef enum {
  TRF_MSG__MESSAGE_WRAPPER__WDATA__NOT_SET = 0,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_CLIENT_HELLO = 2,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_SERVER_HELLO = 3,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_SERVER_REJECT = 4,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_DISCONNECT = 9,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_CURSOR_DATA = 10,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_CLIENT_F_REQ = 11,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_SERVER_N_CHUNK = 12,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_SERVER_ACK_F_REQ = 13,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_CLIENT_CAP = 20,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_SERVER_CAP = 21,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_ENDPOINT = 22,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_CLIENT_DISP_REQ = 23,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_SERVER_DISP = 24,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_CLIENT_REQ = 25,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_SERVER_ACK = 26,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_ADDR_PF = 29,
  TRF_MSG__MESSAGE_WRAPPER__WDATA_CH_OPEN = 30
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRF_MSG__MESSAGE_WRAPPER__WDATA)
} TrfMsg__MessageWrapper__WdataCase;

/**
 *  @brief Message wrapper
 *All TRF messages are contained within a message wrapper, identifying the
 *client using the session_id, with one message payload contained within
 *wdata.
 */
struct  _TrfMsg__MessageWrapper
{
  ProtobufCMessage base;
  /**
   *  @brief Session identifier 
   */
  uint64_t session_id;
  TrfMsg__MessageWrapper__WdataCase wdata_case;
  union {
    TrfMsg__ClientHello *client_hello;
    TrfMsg__ServerHello *server_hello;
    TrfMsg__ServerReject *server_reject;
    TrfMsg__Disconnect *disconnect;
    TrfMsg__CursorData *cursor_data;
    TrfMsg__ClientFReq *client_f_req;
    TrfMsg__ServerNotifyChunk *server_n_chunk;
    TrfMsg__ServerAckFReq *server_ack_f_req;
    TrfMsg__ClientCap *client_cap;
    TrfMsg__ServerCap *server_cap;
    TrfMsg__Endpoint *endpoint;
    TrfMsg__ClientDispReq *client_disp_req;
    TrfMsg__ServerDisp *server_disp;
    TrfMsg__ClientReq *client_req;
    TrfMsg__ServerAckReq *server_ack;
    TrfMsg__AddrPF *addr_pf;
    TrfMsg__ChannelOpen *ch_open;
  };
};
#define TRF_MSG__MESSAGE_WRAPPER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&trf_msg__message_wrapper__descriptor) \
    , 0, TRF_MSG__MESSAGE_WRAPPER__WDATA__NOT_SET, {0} }


/* TrfMsg__APIVersion methods */
void   trf_msg__apiversion__init
                     (TrfMsg__APIVersion         *message);
size_t trf_msg__apiversion__get_packed_size
                     (const TrfMsg__APIVersion   *message);
size_t trf_msg__apiversion__pack
                     (const TrfMsg__APIVersion   *message,
                      uint8_t             *out);
size_t trf_msg__apiversion__pack_to_buffer
                     (const TrfMsg__APIVersion   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__APIVersion *
       trf_msg__apiversion__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__apiversion__free_unpacked
                     (TrfMsg__APIVersion *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__LibraryVersion methods */
void   trf_msg__library_version__init
                     (TrfMsg__LibraryVersion         *message);
size_t trf_msg__library_version__get_packed_size
                     (const TrfMsg__LibraryVersion   *message);
size_t trf_msg__library_version__pack
                     (const TrfMsg__LibraryVersion   *message,
                      uint8_t             *out);
size_t trf_msg__library_version__pack_to_buffer
                     (const TrfMsg__LibraryVersion   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__LibraryVersion *
       trf_msg__library_version__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__library_version__free_unpacked
                     (TrfMsg__LibraryVersion *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__AddrCand methods */
void   trf_msg__addr_cand__init
                     (TrfMsg__AddrCand         *message);
size_t trf_msg__addr_cand__get_packed_size
                     (const TrfMsg__AddrCand   *message);
size_t trf_msg__addr_cand__pack
                     (const TrfMsg__AddrCand   *message,
                      uint8_t             *out);
size_t trf_msg__addr_cand__pack_to_buffer
                     (const TrfMsg__AddrCand   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__AddrCand *
       trf_msg__addr_cand__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__addr_cand__free_unpacked
                     (TrfMsg__AddrCand *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__Transport methods */
void   trf_msg__transport__init
                     (TrfMsg__Transport         *message);
size_t trf_msg__transport__get_packed_size
                     (const TrfMsg__Transport   *message);
size_t trf_msg__transport__pack
                     (const TrfMsg__Transport   *message,
                      uint8_t             *out);
size_t trf_msg__transport__pack_to_buffer
                     (const TrfMsg__Transport   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__Transport *
       trf_msg__transport__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__transport__free_unpacked
                     (TrfMsg__Transport *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__Display methods */
void   trf_msg__display__init
                     (TrfMsg__Display         *message);
size_t trf_msg__display__get_packed_size
                     (const TrfMsg__Display   *message);
size_t trf_msg__display__pack
                     (const TrfMsg__Display   *message,
                      uint8_t             *out);
size_t trf_msg__display__pack_to_buffer
                     (const TrfMsg__Display   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__Display *
       trf_msg__display__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__display__free_unpacked
                     (TrfMsg__Display *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ClientHello methods */
void   trf_msg__client_hello__init
                     (TrfMsg__ClientHello         *message);
size_t trf_msg__client_hello__get_packed_size
                     (const TrfMsg__ClientHello   *message);
size_t trf_msg__client_hello__pack
                     (const TrfMsg__ClientHello   *message,
                      uint8_t             *out);
size_t trf_msg__client_hello__pack_to_buffer
                     (const TrfMsg__ClientHello   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ClientHello *
       trf_msg__client_hello__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__client_hello__free_unpacked
                     (TrfMsg__ClientHello *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ServerHello methods */
void   trf_msg__server_hello__init
                     (TrfMsg__ServerHello         *message);
size_t trf_msg__server_hello__get_packed_size
                     (const TrfMsg__ServerHello   *message);
size_t trf_msg__server_hello__pack
                     (const TrfMsg__ServerHello   *message,
                      uint8_t             *out);
size_t trf_msg__server_hello__pack_to_buffer
                     (const TrfMsg__ServerHello   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ServerHello *
       trf_msg__server_hello__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__server_hello__free_unpacked
                     (TrfMsg__ServerHello *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ServerReject methods */
void   trf_msg__server_reject__init
                     (TrfMsg__ServerReject         *message);
size_t trf_msg__server_reject__get_packed_size
                     (const TrfMsg__ServerReject   *message);
size_t trf_msg__server_reject__pack
                     (const TrfMsg__ServerReject   *message,
                      uint8_t             *out);
size_t trf_msg__server_reject__pack_to_buffer
                     (const TrfMsg__ServerReject   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ServerReject *
       trf_msg__server_reject__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__server_reject__free_unpacked
                     (TrfMsg__ServerReject *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__AddrPF methods */
void   trf_msg__addr_pf__init
                     (TrfMsg__AddrPF         *message);
size_t trf_msg__addr_pf__get_packed_size
                     (const TrfMsg__AddrPF   *message);
size_t trf_msg__addr_pf__pack
                     (const TrfMsg__AddrPF   *message,
                      uint8_t             *out);
size_t trf_msg__addr_pf__pack_to_buffer
                     (const TrfMsg__AddrPF   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__AddrPF *
       trf_msg__addr_pf__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__addr_pf__free_unpacked
                     (TrfMsg__AddrPF *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ClientCap methods */
void   trf_msg__client_cap__init
                     (TrfMsg__ClientCap         *message);
size_t trf_msg__client_cap__get_packed_size
                     (const TrfMsg__ClientCap   *message);
size_t trf_msg__client_cap__pack
                     (const TrfMsg__ClientCap   *message,
                      uint8_t             *out);
size_t trf_msg__client_cap__pack_to_buffer
                     (const TrfMsg__ClientCap   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ClientCap *
       trf_msg__client_cap__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__client_cap__free_unpacked
                     (TrfMsg__ClientCap *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ServerCap methods */
void   trf_msg__server_cap__init
                     (TrfMsg__ServerCap         *message);
size_t trf_msg__server_cap__get_packed_size
                     (const TrfMsg__ServerCap   *message);
size_t trf_msg__server_cap__pack
                     (const TrfMsg__ServerCap   *message,
                      uint8_t             *out);
size_t trf_msg__server_cap__pack_to_buffer
                     (const TrfMsg__ServerCap   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ServerCap *
       trf_msg__server_cap__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__server_cap__free_unpacked
                     (TrfMsg__ServerCap *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__Endpoint methods */
void   trf_msg__endpoint__init
                     (TrfMsg__Endpoint         *message);
size_t trf_msg__endpoint__get_packed_size
                     (const TrfMsg__Endpoint   *message);
size_t trf_msg__endpoint__pack
                     (const TrfMsg__Endpoint   *message,
                      uint8_t             *out);
size_t trf_msg__endpoint__pack_to_buffer
                     (const TrfMsg__Endpoint   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__Endpoint *
       trf_msg__endpoint__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__endpoint__free_unpacked
                     (TrfMsg__Endpoint *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ClientDispReq methods */
void   trf_msg__client_disp_req__init
                     (TrfMsg__ClientDispReq         *message);
size_t trf_msg__client_disp_req__get_packed_size
                     (const TrfMsg__ClientDispReq   *message);
size_t trf_msg__client_disp_req__pack
                     (const TrfMsg__ClientDispReq   *message,
                      uint8_t             *out);
size_t trf_msg__client_disp_req__pack_to_buffer
                     (const TrfMsg__ClientDispReq   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ClientDispReq *
       trf_msg__client_disp_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__client_disp_req__free_unpacked
                     (TrfMsg__ClientDispReq *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ServerDisp methods */
void   trf_msg__server_disp__init
                     (TrfMsg__ServerDisp         *message);
size_t trf_msg__server_disp__get_packed_size
                     (const TrfMsg__ServerDisp   *message);
size_t trf_msg__server_disp__pack
                     (const TrfMsg__ServerDisp   *message,
                      uint8_t             *out);
size_t trf_msg__server_disp__pack_to_buffer
                     (const TrfMsg__ServerDisp   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ServerDisp *
       trf_msg__server_disp__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__server_disp__free_unpacked
                     (TrfMsg__ServerDisp *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ClientReq methods */
void   trf_msg__client_req__init
                     (TrfMsg__ClientReq         *message);
size_t trf_msg__client_req__get_packed_size
                     (const TrfMsg__ClientReq   *message);
size_t trf_msg__client_req__pack
                     (const TrfMsg__ClientReq   *message,
                      uint8_t             *out);
size_t trf_msg__client_req__pack_to_buffer
                     (const TrfMsg__ClientReq   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ClientReq *
       trf_msg__client_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__client_req__free_unpacked
                     (TrfMsg__ClientReq *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ServerAckReq methods */
void   trf_msg__server_ack_req__init
                     (TrfMsg__ServerAckReq         *message);
size_t trf_msg__server_ack_req__get_packed_size
                     (const TrfMsg__ServerAckReq   *message);
size_t trf_msg__server_ack_req__pack
                     (const TrfMsg__ServerAckReq   *message,
                      uint8_t             *out);
size_t trf_msg__server_ack_req__pack_to_buffer
                     (const TrfMsg__ServerAckReq   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ServerAckReq *
       trf_msg__server_ack_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__server_ack_req__free_unpacked
                     (TrfMsg__ServerAckReq *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__DisplayReq methods */
void   trf_msg__display_req__init
                     (TrfMsg__DisplayReq         *message);
size_t trf_msg__display_req__get_packed_size
                     (const TrfMsg__DisplayReq   *message);
size_t trf_msg__display_req__pack
                     (const TrfMsg__DisplayReq   *message,
                      uint8_t             *out);
size_t trf_msg__display_req__pack_to_buffer
                     (const TrfMsg__DisplayReq   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__DisplayReq *
       trf_msg__display_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__display_req__free_unpacked
                     (TrfMsg__DisplayReq *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ClientFReq methods */
void   trf_msg__client_freq__init
                     (TrfMsg__ClientFReq         *message);
size_t trf_msg__client_freq__get_packed_size
                     (const TrfMsg__ClientFReq   *message);
size_t trf_msg__client_freq__pack
                     (const TrfMsg__ClientFReq   *message,
                      uint8_t             *out);
size_t trf_msg__client_freq__pack_to_buffer
                     (const TrfMsg__ClientFReq   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ClientFReq *
       trf_msg__client_freq__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__client_freq__free_unpacked
                     (TrfMsg__ClientFReq *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ServerNotifyChunk methods */
void   trf_msg__server_notify_chunk__init
                     (TrfMsg__ServerNotifyChunk         *message);
size_t trf_msg__server_notify_chunk__get_packed_size
                     (const TrfMsg__ServerNotifyChunk   *message);
size_t trf_msg__server_notify_chunk__pack
                     (const TrfMsg__ServerNotifyChunk   *message,
                      uint8_t             *out);
size_t trf_msg__server_notify_chunk__pack_to_buffer
                     (const TrfMsg__ServerNotifyChunk   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ServerNotifyChunk *
       trf_msg__server_notify_chunk__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__server_notify_chunk__free_unpacked
                     (TrfMsg__ServerNotifyChunk *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ServerAckFReq methods */
void   trf_msg__server_ack_freq__init
                     (TrfMsg__ServerAckFReq         *message);
size_t trf_msg__server_ack_freq__get_packed_size
                     (const TrfMsg__ServerAckFReq   *message);
size_t trf_msg__server_ack_freq__pack
                     (const TrfMsg__ServerAckFReq   *message,
                      uint8_t             *out);
size_t trf_msg__server_ack_freq__pack_to_buffer
                     (const TrfMsg__ServerAckFReq   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ServerAckFReq *
       trf_msg__server_ack_freq__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__server_ack_freq__free_unpacked
                     (TrfMsg__ServerAckFReq *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__CursorData methods */
void   trf_msg__cursor_data__init
                     (TrfMsg__CursorData         *message);
size_t trf_msg__cursor_data__get_packed_size
                     (const TrfMsg__CursorData   *message);
size_t trf_msg__cursor_data__pack
                     (const TrfMsg__CursorData   *message,
                      uint8_t             *out);
size_t trf_msg__cursor_data__pack_to_buffer
                     (const TrfMsg__CursorData   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__CursorData *
       trf_msg__cursor_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__cursor_data__free_unpacked
                     (TrfMsg__CursorData *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__Disconnect methods */
void   trf_msg__disconnect__init
                     (TrfMsg__Disconnect         *message);
size_t trf_msg__disconnect__get_packed_size
                     (const TrfMsg__Disconnect   *message);
size_t trf_msg__disconnect__pack
                     (const TrfMsg__Disconnect   *message,
                      uint8_t             *out);
size_t trf_msg__disconnect__pack_to_buffer
                     (const TrfMsg__Disconnect   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__Disconnect *
       trf_msg__disconnect__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__disconnect__free_unpacked
                     (TrfMsg__Disconnect *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__ChannelOpen methods */
void   trf_msg__channel_open__init
                     (TrfMsg__ChannelOpen         *message);
size_t trf_msg__channel_open__get_packed_size
                     (const TrfMsg__ChannelOpen   *message);
size_t trf_msg__channel_open__pack
                     (const TrfMsg__ChannelOpen   *message,
                      uint8_t             *out);
size_t trf_msg__channel_open__pack_to_buffer
                     (const TrfMsg__ChannelOpen   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__ChannelOpen *
       trf_msg__channel_open__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__channel_open__free_unpacked
                     (TrfMsg__ChannelOpen *message,
                      ProtobufCAllocator *allocator);
/* TrfMsg__MessageWrapper methods */
void   trf_msg__message_wrapper__init
                     (TrfMsg__MessageWrapper         *message);
size_t trf_msg__message_wrapper__get_packed_size
                     (const TrfMsg__MessageWrapper   *message);
size_t trf_msg__message_wrapper__pack
                     (const TrfMsg__MessageWrapper   *message,
                      uint8_t             *out);
size_t trf_msg__message_wrapper__pack_to_buffer
                     (const TrfMsg__MessageWrapper   *message,
                      ProtobufCBuffer     *buffer);
TrfMsg__MessageWrapper *
       trf_msg__message_wrapper__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   trf_msg__message_wrapper__free_unpacked
                     (TrfMsg__MessageWrapper *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*TrfMsg__APIVersion_Closure)
                 (const TrfMsg__APIVersion *message,
                  void *closure_data);
typedef void (*TrfMsg__LibraryVersion_Closure)
                 (const TrfMsg__LibraryVersion *message,
                  void *closure_data);
typedef void (*TrfMsg__AddrCand_Closure)
                 (const TrfMsg__AddrCand *message,
                  void *closure_data);
typedef void (*TrfMsg__Transport_Closure)
                 (const TrfMsg__Transport *message,
                  void *closure_data);
typedef void (*TrfMsg__Display_Closure)
                 (const TrfMsg__Display *message,
                  void *closure_data);
typedef void (*TrfMsg__ClientHello_Closure)
                 (const TrfMsg__ClientHello *message,
                  void *closure_data);
typedef void (*TrfMsg__ServerHello_Closure)
                 (const TrfMsg__ServerHello *message,
                  void *closure_data);
typedef void (*TrfMsg__ServerReject_Closure)
                 (const TrfMsg__ServerReject *message,
                  void *closure_data);
typedef void (*TrfMsg__AddrPF_Closure)
                 (const TrfMsg__AddrPF *message,
                  void *closure_data);
typedef void (*TrfMsg__ClientCap_Closure)
                 (const TrfMsg__ClientCap *message,
                  void *closure_data);
typedef void (*TrfMsg__ServerCap_Closure)
                 (const TrfMsg__ServerCap *message,
                  void *closure_data);
typedef void (*TrfMsg__Endpoint_Closure)
                 (const TrfMsg__Endpoint *message,
                  void *closure_data);
typedef void (*TrfMsg__ClientDispReq_Closure)
                 (const TrfMsg__ClientDispReq *message,
                  void *closure_data);
typedef void (*TrfMsg__ServerDisp_Closure)
                 (const TrfMsg__ServerDisp *message,
                  void *closure_data);
typedef void (*TrfMsg__ClientReq_Closure)
                 (const TrfMsg__ClientReq *message,
                  void *closure_data);
typedef void (*TrfMsg__ServerAckReq_Closure)
                 (const TrfMsg__ServerAckReq *message,
                  void *closure_data);
typedef void (*TrfMsg__DisplayReq_Closure)
                 (const TrfMsg__DisplayReq *message,
                  void *closure_data);
typedef void (*TrfMsg__ClientFReq_Closure)
                 (const TrfMsg__ClientFReq *message,
                  void *closure_data);
typedef void (*TrfMsg__ServerNotifyChunk_Closure)
                 (const TrfMsg__ServerNotifyChunk *message,
                  void *closure_data);
typedef void (*TrfMsg__ServerAckFReq_Closure)
                 (const TrfMsg__ServerAckFReq *message,
                  void *closure_data);
typedef void (*TrfMsg__CursorData_Closure)
                 (const TrfMsg__CursorData *message,
                  void *closure_data);
typedef void (*TrfMsg__Disconnect_Closure)
                 (const TrfMsg__Disconnect *message,
                  void *closure_data);
typedef void (*TrfMsg__ChannelOpen_Closure)
                 (const TrfMsg__ChannelOpen *message,
                  void *closure_data);
typedef void (*TrfMsg__MessageWrapper_Closure)
                 (const TrfMsg__MessageWrapper *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor trf_msg__apiversion__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__library_version__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__addr_cand__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__transport__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__display__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__client_hello__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__server_hello__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__server_reject__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__addr_pf__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__client_cap__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__server_cap__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__endpoint__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__client_disp_req__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__server_disp__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__client_req__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__server_ack_req__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__display_req__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__client_freq__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__server_notify_chunk__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__server_ack_freq__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__cursor_data__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__disconnect__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__channel_open__descriptor;
extern const ProtobufCMessageDescriptor trf_msg__message_wrapper__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_trf_5fmsg_2eproto__INCLUDED */
